/************************************************************************************************/
/** 
 * @file		KsThread.cpp
 * @brief		スレッド管理
 * @author		Tsukasa Kato
 * @date		2004/08/17
 * @since		----/--/--
 * @version		1.0
 */
/************************************************************************************************/

/*==============================================================================================*/
/*                                 << インクルード >>                                          */
/*==============================================================================================*/
#include "KsEngine/KsEnginePreCompile.h"
#include "KsThread.h"

/*==============================================================================================*/
/*                                     << 定義 >>                                               */
/*==============================================================================================*/

/*==============================================================================================*/
/*                                     << 宣言 >>                                               */
/*==============================================================================================*/

/************************************************************************************************/
/*
 * コンストラクタ
 */
/************************************************************************************************/
KsThread::KsThread() : m_bJoin( ksFALSE )
{
	m_handle = reinterpret_cast<void*>( ::GetCurrentThread() );
	m_id     = ::GetCurrentThreadId();
}

/************************************************************************************************/
/*
 * コンストラクタ
 * @param	pParam		パラメータ
 */
/************************************************************************************************/
KsThread::KsThread( KsThreadFunc func, void* pParam ) : m_bJoin( ksTRUE )
{
	//KsThreadParam	param( func, pParam );

	m_handle = reinterpret_cast<void*>( _beginthreadex( 0, 0, func, pParam, 0, &m_id ) );
	//m_handle = reinterpret_cast<void*>( _beginthreadex( 0, 0, func, pParam, CREATE_SUSPENDED, &m_id ) );
}

/************************************************************************************************/
/*
 * デストラクタ
 */
/************************************************************************************************/
KsThread::~KsThread()
{
	destroy();
}

/************************************************************************************************/
/*
 * == 演算子オーバーロード
 * @retval	ksTRUE		等しい
 * @retval	ksFALSE		等しくない
 */
/************************************************************************************************/
KsBool KsThread::operator == ( const KsThread& other ) const
{
	return ( other.m_id == m_id );
}

/************************************************************************************************/
/*
 * != 演算子オーバーロード
 * @retval	ksTRUE		等しくない
 * @retval	ksFALSE		等しい
 */
/************************************************************************************************/
KsBool KsThread::operator != ( const KsThread& other ) const
{
	return !( operator == (other) );
}

/************************************************************************************************/
/*
 * スレッドを破棄する
 */
/************************************************************************************************/
void KsThread::destroy()
{
	if( m_handle )
	{
		KsInt32	result = 0;

		result = ::CloseHandle(reinterpret_cast<HANDLE>(m_handle));

		KsAssertEx( result );

		m_handle = 0;
	}
}

/************************************************************************************************/
/*
 * スレッド処理を開始する
 */
/************************************************************************************************/
void KsThread::start()
{
	if( !m_bJoin )
	{
		m_handle = reinterpret_cast<void*>( _beginthreadex( 0, 0, KsThreadMainFunc, this, 0, &m_id ) );
		m_bJoin  = ksTRUE;
		return;
	}

	if( m_handle != NULL )
	{
		::ResumeThread( m_handle );
	}
}

/************************************************************************************************/
/*
 * スレッドの終了を待機する
 */
/************************************************************************************************/
void KsThread::join()
{
	KsAssertEx( m_bJoin );

	KsInt32	result = 0;

	/* 無限に待つ */
	result = ::WaitForSingleObject(reinterpret_cast<HANDLE>(m_handle), INFINITE);

	KsAssertEx( result == WAIT_OBJECT_0 );
	result = ::CloseHandle(reinterpret_cast<HANDLE>(m_handle));
	KsAssertEx(result);

	m_handle = 0;

	m_bJoin = ksFALSE;
}

/************************************************************************************************/
/*
 * プライオリティをセットする
 * @param	priority	プライオリティ
 */
/************************************************************************************************/
void KsThread::setPriority( ksTHREAD_PRIORITY_TYPE priority )
{
	::SetThreadPriority( m_handle, priority );
}

/************************************************************************************************/
/*
 * 使用プロセッサをセットする
 * @param	prosessor	使用プロセッサ番号
 */
/************************************************************************************************/
KsBool KsThread::setProcessor( KsUInt32 prosessor )
{
#if(_WIN32_WINNT >= 0x0400)
	::SetThreadIdealProcessor( reinterpret_cast<HANDLE>(m_handle), static_cast<DWORD>(prosessor) );
#else
	::SetThreadAffinityMask( reinterpret_cast<HANDLE>(m_handle), static_cast<DWORD>( 1 << prosessor ) );
#endif 
	return ksTRUE;
}

/************************************************************************************************/
/*
 * スレッドを待機する
 */
/************************************************************************************************/
void KsThread::wait( KsHandle handle )
{
	/* 無限に待つ */
	::WaitForSingleObject(reinterpret_cast<HANDLE>(handle), INFINITE);
}

/************************************************************************************************/
/*
 * スレッドのメイン関数
 * @return	実行終了結果
 */
/************************************************************************************************/
KsUInt32 KsThread::threadMain()
{
	return 0;
}

/************************************************************************************************/
/*
 * 指定時間現在のスレッドの実行を休止する
 * @param	time		待ち時間(ms)
 */
/************************************************************************************************/
void KsThread::sleep( const KsUInt32 time )
{
	::Sleep( time );
}

/************************************************************************************************/
/*
 * 現在のスレッドの実行を中断して他のスレッドへ実行を譲ります。
 */
/************************************************************************************************/
void KsThread::yield()
{
	::Sleep( 0 );
}

/************************************************************************************************/
/*
 * 指定された変数の値をインクリメントし（1 つ増やします）
 */
/************************************************************************************************/
KsLong KsThread::interlockedIncrement( KsLong* pCount )
{
	return InterlockedIncrement( pCount );
}

/************************************************************************************************/
/*
 * 指定された変数の値をデクリメントし（1 つ減らします）
 */
/************************************************************************************************/
KsLong KsThread::interlockedDecrement( KsLong* pCount )
{
	return InterlockedDecrement( pCount );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
KsUInt32 __stdcall KsThreadMainFunc( void* pParam )
{
	KsThread* pThread = reinterpret_cast< KsThread* >( pParam );

	const KsUInt32	ret = pThread->threadMain();

	_endthreadex( 0 );

	return ret;
}


