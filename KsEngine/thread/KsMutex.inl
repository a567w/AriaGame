/************************************************************************************************/
/** 
 * @file		KsMutex.inl
 * @brief		排他制御クラスインライン
 * @author		Tsukasa Kato
 * @date		2004/08/17
 * @since		----/--/--
 * @version		1.0.0
 */
/************************************************************************************************/

/*==============================================================================================*/
/*                                 << インクルード >>                                           */
/*==============================================================================================*/

/*==============================================================================================*/
/*                                     << 定義 >>                                               */
/*==============================================================================================*/
#define KS_ONCE_INIT	( 0 )

typedef KsLong		KsOnceFlag;
typedef KsBool		(WINAPI* TryEnterCriticalSection_type)( LPCRITICAL_SECTION lpCriticalSection );

/*==============================================================================================*/
/*                                     << 宣言 >>                                               */
/*==============================================================================================*/
TryEnterCriticalSection_type g_TryEnterCriticalSection = 0;

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline HANDLE mutex_cast( void* p )
{
    return reinterpret_cast<HANDLE>( p );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline LPCRITICAL_SECTION critical_section_cast( void* p )
{
    return reinterpret_cast<LPCRITICAL_SECTION>( p );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void* new_critical_section()
{
	LPCRITICAL_SECTION	critical_section = new CRITICAL_SECTION;

	if( critical_section == 0 )
	{
		return NULL;
	}

	::InitializeCriticalSection(critical_section);

	return critical_section;	
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void* new_mutex( const KsChar* name )
{
    HANDLE mutex = CreateMutex( 0, 0, name );

	if( mutex == 0 || mutex == INVALID_HANDLE_VALUE )
	{
       return NULL;
	}

    return reinterpret_cast<void*>(mutex);
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void delete_critical_section( void* mutex )
{
	::DeleteCriticalSection( critical_section_cast( mutex ) );

    delete critical_section_cast( mutex );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void delete_mutex( void* mutex )
{
    KsInt32		result = 0;

	result = ::CloseHandle( mutex_cast( mutex ) );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void wait_critical_section_infinite( void* mutex )
{
	::EnterCriticalSection( critical_section_cast( mutex ) );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline bool wait_critical_section_try( void* mutex )
{
	KsBool	result = g_TryEnterCriticalSection( critical_section_cast( mutex ) );

	return ( result != 0 );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline KsInt32 wait_mutex( void* mutex, KsUInt32 time )
{
	KsUInt32	result = 0;

	result = ::WaitForSingleObject( mutex_cast( mutex ), time );

	return static_cast<KsInt32>( result );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void release_critical_section( void* mutex )
{
	LeaveCriticalSection( critical_section_cast( mutex ) );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
inline void release_mutex( void* mutex )
{
	KsBool	result = FALSE;

	result = ::ReleaseMutex( mutex_cast( mutex ) );
}

