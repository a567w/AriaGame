/************************************************************************************************/
/** 
 * @file		KsThreadContext.cpp
 * @brief		スレッド管理
 * @author		Tsukasa Kato
 * @date		2004/08/17
 * @since		----/--/--
 * @version		1.0
 */
/************************************************************************************************/

/*==============================================================================================*/
/*                                 << インクルード >>                                          */
/*==============================================================================================*/
#include "KsEngine/KsEnginePreCompile.h"
#include "KsThreadContext.h"

/*==============================================================================================*/
/*                                     << 定義 >>                                               */
/*==============================================================================================*/

/*==============================================================================================*/
/*                                     << 宣言 >>                                               */
/*==============================================================================================*/

/************************************************************************************************/
/*
 * コンストラクタ
 */
/************************************************************************************************/
KsThreadContext::KsThreadContext() : m_bJoin( ksFALSE )
{
	m_handle = reinterpret_cast<void*>( ::GetCurrentThread() );
	m_id     = ::GetCurrentThreadId();
}

/************************************************************************************************/
/*
 * デストラクタ
 */
/************************************************************************************************/
KsThreadContext::~KsThreadContext()
{
	destroy();
}

/************************************************************************************************/
/*
 * スレッドを破棄する
 */
/************************************************************************************************/
void KsThreadContext::destroy()
{
	if( m_handle )
	{
		KsInt32	result = 0;

		result = ::CloseHandle(reinterpret_cast<HANDLE>(m_handle));

		KsAssertEx( result );

		m_handle = 0;
	}
}

/************************************************************************************************/
/*
 * スレッド処理を開始する
 */
/************************************************************************************************/
void KsThreadContext::start()
{
	if( m_handle != NULL )
	{
		::ResumeThread( m_handle );
	}
}

/************************************************************************************************/
/*
 * スレッドの終了を待機する
 */
/************************************************************************************************/
void KsThreadContext::join()
{
	KsAssertEx( m_bJoin );

	KsInt32	result = 0;

	/* 無限に待つ */
	result = ::WaitForSingleObject(reinterpret_cast<HANDLE>(m_handle), INFINITE);

	KsAssertEx( result == WAIT_OBJECT_0 );
	result = ::CloseHandle(reinterpret_cast<HANDLE>(m_handle));
	KsAssertEx(result);

	m_handle = 0;

	m_bJoin = ksFALSE;
}

/************************************************************************************************/
/*
 * プライオリティをセットする
 * @param	priority	プライオリティ
 */
/************************************************************************************************/
void KsThreadContext::setPriority( ksTHREAD_PRIORITY_TYPE priority )
{
	::SetThreadPriority( m_handle, priority );
}

/************************************************************************************************/
/*
 * 使用プロセッサをセットする
 * @param	prosessor	使用プロセッサ番号
 */
/************************************************************************************************/
KsBool KsThreadContext::setProcessor( KsUInt32 prosessor )
{
#if(_WIN32_WINNT >= 0x0400)
	::SetThreadIdealProcessor( reinterpret_cast<HANDLE>(m_handle), static_cast<DWORD>(prosessor) );
#else
	::SetThreadAffinityMask( reinterpret_cast<HANDLE>(m_handle), static_cast<DWORD>( 1 << prosessor ) );
#endif 
	return ksTRUE;
}

/************************************************************************************************/
/*
 * スレッドを待機する
 */
/************************************************************************************************/
void KsThreadContext::wait( KsHandle handle )
{
	/* 無限に待つ */
	::WaitForSingleObject(reinterpret_cast<HANDLE>(handle), INFINITE);
}

/************************************************************************************************/
/*
 * スレッドのメイン関数
 * @return	実行終了結果
 */
/************************************************************************************************/
KsUInt32 KsThreadContext::threadMain()
{
	return 0;
}

/************************************************************************************************/
/*
 * 指定時間現在のスレッドの実行を休止する
 * @param	time		待ち時間(ms)
 */
/************************************************************************************************/
void KsThreadContext::sleep( const KsUInt32 time )
{
	::Sleep( time );
}

/************************************************************************************************/
/*
 * 現在のスレッドの実行を中断して他のスレッドへ実行を譲ります。
 */
/************************************************************************************************/
void KsThreadContext::yield()
{
	::Sleep( 0 );
}

/************************************************************************************************/
/*
 * 指定された変数の値をインクリメントし（1 つ増やします）
 */
/************************************************************************************************/
KsLong KsThreadContext::interlockedIncrement( KsLong* pCount )
{
	return InterlockedIncrement( pCount );
}

/************************************************************************************************/
/*
 * 指定された変数の値をデクリメントし（1 つ減らします）
 */
/************************************************************************************************/
KsLong KsThreadContext::interlockedDecrement( KsLong* pCount )
{
	return InterlockedDecrement( pCount );
}

/************************************************************************************************/
/*
 *
 */
/************************************************************************************************/
KsUInt32 __stdcall KsThreadContextMainFunc( void* pParam )
{
	KsThreadContext* pThread = reinterpret_cast< KsThreadContext* >( pParam );

#if 0
	TlsSetValue( s_contextTlsIndex, &pThread->m_context );

	// take ownership of the allocator:
	if( pThread->m_context.pAllocator != nullptr )
	{
			pThread->m_context.pAllocator->setOwnerThread( pThread );
	}
#endif

	return pThread->threadMain();
}


